-- start_ignore
create or replace function get_explain_xml_output(query_string text)
returns xml as
$$
declare
  x xml;
begin
  execute 'explain (format xml) ' || query_string
  into x;
  return x;
end;
$$ language plpgsql;
create or replace function get_motion_snd_recv(query_string text)
returns table(node_name xml, motion_snd xml, motion_recv xml) as
$_$
declare
  node_xml      text := '//*[local-name()="Node-Type"][contains(text(), "Motion")]/../*[local-name()="Node-Type"]/text()';
  motion_snd    text := '//*[local-name()="Node-Type"][contains(text(), "Motion")]/../*[local-name()="Senders"]/text()';
  motion_recv   text := '//*[local-name()="Node-Type"][contains(text(), "Motion")]/../*[local-name()="Receivers"]/text()';
begin
   return query
   execute 'select unnest(xpath(''' || node_xml || ''', x)) node_name,
                   unnest(xpath(''' || motion_snd || ''', x)) motion_snd,
                   unnest(xpath(''' || motion_recv || ''', x)) motion_recv
            from get_explain_xml_output($$' || query_string || '$$) as x';
end;
$_$ language plpgsql;
create table scale_factor_repl(c1 int, c2 int) distributed replicated;
create table scale_factor_distr(c1 int, c2 int) distributed by (c1);
create table scale_factor_rand_distr(c1 int, c2 int) distributed randomly;
create table scale_factor_partitioned (a int) partition by range(a) (start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_1" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_2" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_3" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_4" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_5" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_6" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_7" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_8" for table "scale_factor_partitioned"
NOTICE:  CREATE TABLE will create partition "scale_factor_partitioned_1_prt_9" for table "scale_factor_partitioned"
create table scale_factor_master_only (a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
set allow_system_table_mods=true;
delete from gp_distribution_policy where localoid='scale_factor_master_only'::regclass;
reset allow_system_table_mods;
set allow_system_table_mods = on;
create table scale_factor_part_distr(c1 int, c2 int) distributed by(c1);
update gp_distribution_policy set numsegments = 2 where localoid = 'scale_factor_part_distr'::regclass;
reset allow_system_table_mods;
insert into scale_factor_repl select i,i from generate_series(1, 10)i;
insert into scale_factor_distr select i,i from generate_series(1, 10)i;
insert into scale_factor_rand_distr select i,i from generate_series(5, 15)i;
insert into scale_factor_part_distr select i,i from generate_series(1, 10)i;
insert into scale_factor_partitioned values (1), (1), (1);
insert into scale_factor_master_only select generate_series(1, 10);
analyze scale_factor_repl;
analyze scale_factor_distr;
analyze scale_factor_rand_distr;
analyze scale_factor_part_distr;
analyze scale_factor_partitioned;
analyze scale_factor_master_only;
-- end_ignore
-- This plan from postgres optimizer may seem incorrect at the first glance, but in fact
-- Gather Motion has fractional number of rows, which is 3.3... and this number was rounded up
-- to 4. Also, Hash Semi Join below this motion has the same rows number, but scaled by
-- segments number, which is 3 in our case. That is, we get 1.1 rows and round them to 2.
explain select * from scale_factor_distr where c2 in (select c1/2 from scale_factor_rand_distr limit 3);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice5; segments: 3)  (cost=0.00..862.00 rows=10 width=8)
   ->  Hash Join  (cost=0.00..862.00 rows=4 width=8)
         Hash Cond: (scale_factor_distr.c2 = ((scale_factor_rand_distr.c1 / 2)))
         ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..431.00 rows=4 width=8)
               Hash Key: scale_factor_distr.c2
               ->  Seq Scan on scale_factor_distr  (cost=0.00..431.00 rows=4 width=8)
         ->  Hash  (cost=431.00..431.00 rows=1 width=4)
               ->  GroupAggregate  (cost=0.00..431.00 rows=1 width=4)
                     Group Key: ((scale_factor_rand_distr.c1 / 2))
                     ->  Sort  (cost=0.00..431.00 rows=1 width=4)
                           Sort Key: ((scale_factor_rand_distr.c1 / 2))
                           ->  Redistribute Motion 3:3  (slice4; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                                 Hash Key: ((scale_factor_rand_distr.c1 / 2))
                                 ->  GroupAggregate  (cost=0.00..431.00 rows=1 width=4)
                                       Group Key: ((scale_factor_rand_distr.c1 / 2))
                                       ->  Sort  (cost=0.00..431.00 rows=1 width=4)
                                             Sort Key: ((scale_factor_rand_distr.c1 / 2))
                                             ->  Result  (cost=0.00..431.00 rows=1 width=4)
                                                   ->  Redistribute Motion 1:3  (slice3)  (cost=0.00..431.00 rows=3 width=4)
                                                         ->  Limit  (cost=0.00..431.00 rows=3 width=4)
                                                               ->  Gather Motion 3:1  (slice2; segments: 3)  (cost=0.00..431.00 rows=3 width=4)
                                                                     ->  Limit  (cost=0.00..431.00 rows=1 width=4)
                                                                           ->  Seq Scan on scale_factor_rand_distr  (cost=0.00..431.00 rows=4 width=4)
 Optimizer: Pivotal Optimizer (GPORCA)
(24 rows)

explain select * from scale_factor_repl limit 1;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit  (cost=0.00..431.00 rows=1 width=8)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..431.00 rows=1 width=8)
         ->  Limit  (cost=0.00..431.00 rows=1 width=8)
               ->  Seq Scan on scale_factor_repl  (cost=0.00..431.00 rows=10 width=8)
 Optimizer: Pivotal Optimizer (GPORCA)
(5 rows)

explain select * from scale_factor_distr where c1 = 2 or c1 = 5 or c1 = 9;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..431.00 rows=4 width=8)
   ->  Seq Scan on scale_factor_distr  (cost=0.00..431.00 rows=2 width=8)
         Filter: ((c1 = 2) OR (c1 = 5) OR (c1 = 9))
 Optimizer: Pivotal Optimizer (GPORCA)
(4 rows)

explain select count(*) from scale_factor_partitioned where a = 1;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=0.00..431.00 rows=1 width=8)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..431.00 rows=3 width=1)
         ->  Result  (cost=0.00..431.00 rows=3 width=1)
               ->  Sequence  (cost=0.00..431.00 rows=3 width=4)
                     ->  Partition Selector for scale_factor_partitioned (dynamic scan id: 1)  (cost=10.00..100.00 rows=100 width=4)
                           Partitions selected: 1 (out of 9)
                     ->  Dynamic Seq Scan on scale_factor_partitioned (dynamic scan id: 1)  (cost=0.00..431.00 rows=3 width=4)
                           Filter: (a = 1)
 Optimizer: Pivotal Optimizer (GPORCA)
(9 rows)

explain select * from scale_factor_part_distr;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2.10 rows=10 width=8)
   ->  Seq Scan on scale_factor_part_distr  (cost=0.00..2.10 rows=5 width=8)
 Optimizer: Postgres query optimizer
(3 rows)

select * from get_motion_snd_recv($$
  update scale_factor_repl a set c1 = b.c2 from scale_factor_part_distr b returning *;
$$);
       node_name        | motion_snd | motion_recv 
------------------------+------------+-------------
 Explicit Gather Motion | 3          | 1
 Broadcast Motion       | 2          | 3
(2 rows)

explain update scale_factor_repl a set c1 = b.c2 from scale_factor_part_distr b returning *;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 3:1  (slice2; segments: 3)  (cost=10000000000.00..10000000006.98 rows=100 width=28)
   ->  Update on scale_factor_repl a  (cost=10000000000.00..10000000006.98 rows=100 width=28)
         ->  Nested Loop  (cost=10000000000.00..10000000006.98 rows=100 width=28)
               ->  Seq Scan on scale_factor_repl a  (cost=0.00..1.10 rows=10 width=14)
               ->  Materialize  (cost=0.00..2.65 rows=10 width=14)
                     ->  Broadcast Motion 2:3  (slice1; segments: 2)  (cost=0.00..2.50 rows=10 width=14)
                           ->  Seq Scan on scale_factor_part_distr b  (cost=0.00..2.10 rows=5 width=14)
 Optimizer: Postgres query optimizer
(8 rows)

select * from get_motion_snd_recv ($$
  delete from scale_factor_part_distr a using scale_factor_rand_distr b where b.c1=a.c2;
$$);
          node_name           | motion_snd | motion_recv 
------------------------------+------------+-------------
 Explicit Redistribute Motion | 2          | 2
 Broadcast Motion             | 3          | 2
(2 rows)

explain delete from scale_factor_part_distr a using scale_factor_rand_distr b where b.c1=a.c2;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Delete on scale_factor_part_distr a  (cost=2.23..5.85 rows=5 width=16)
   ->  Explicit Redistribute Motion 2:2  (slice2; segments: 2)  (cost=2.23..5.85 rows=5 width=16)
         ->  Hash Join  (cost=2.23..5.85 rows=5 width=16)
               Hash Cond: (b.c1 = a.c2)
               ->  Broadcast Motion 3:2  (slice1; segments: 3)  (cost=0.00..3.44 rows=11 width=10)
                     ->  Seq Scan on scale_factor_rand_distr b  (cost=0.00..3.11 rows=4 width=10)
               ->  Hash  (cost=2.10..2.10 rows=5 width=14)
                     ->  Seq Scan on scale_factor_part_distr a  (cost=0.00..2.10 rows=5 width=14)
 Optimizer: Postgres query optimizer
(9 rows)

select * from get_motion_snd_recv($$
  select t1.c1, row_number() over (order by t1.c1 desc) from scale_factor_distr t1 join scale_factor_distr t2 using(c2);
$$);
      node_name      | motion_snd | motion_recv 
---------------------+------------+-------------
 Gather Motion       | 3          | 1
 Redistribute Motion | 3          | 3
 Redistribute Motion | 3          | 3
(3 rows)

explain select t1.c1, row_number() over (order by t1.c1 desc) from scale_factor_distr t1 join scale_factor_distr t2 using(c2);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 WindowAgg  (cost=0.00..862.00 rows=11 width=12)
   Order By: scale_factor_distr.c1
   ->  Gather Motion 3:1  (slice3; segments: 3)  (cost=0.00..862.00 rows=11 width=4)
         Merge Key: scale_factor_distr.c1
         ->  Sort  (cost=0.00..862.00 rows=4 width=4)
               Sort Key: scale_factor_distr.c1
               ->  Hash Join  (cost=0.00..862.00 rows=4 width=4)
                     Hash Cond: (scale_factor_distr.c2 = scale_factor_distr_1.c2)
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..431.00 rows=4 width=8)
                           Hash Key: scale_factor_distr.c2
                           ->  Seq Scan on scale_factor_distr  (cost=0.00..431.00 rows=4 width=8)
                     ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=4 width=4)
                                 Hash Key: scale_factor_distr_1.c2
                                 ->  Seq Scan on scale_factor_distr scale_factor_distr_1  (cost=0.00..431.00 rows=4 width=4)
 Optimizer: Pivotal Optimizer (GPORCA)
(16 rows)

-- start_ignore
drop table scale_factor_repl;
drop table scale_factor_distr;
drop table scale_factor_rand_distr;
drop table scale_factor_part_distr;
drop table scale_factor_partitioned;
drop table scale_factor_master_only;
drop function get_motion_snd_recv(text);
drop function get_explain_xml_output(text);
-- end_ignore
